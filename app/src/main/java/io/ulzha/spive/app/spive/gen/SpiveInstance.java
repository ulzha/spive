// Generated by io.ulzha.spive.codegen.GenerateIocCode - do not edit! Put application logic in Spive
// class that implements SpiveInstance interface.
package io.ulzha.spive.app.spive.gen;

import com.google.common.collect.ImmutableList;
import io.ulzha.spive.app.Spive;
import io.ulzha.spive.app.events.CreateEventLog;
import io.ulzha.spive.app.events.CreateInstance;
import io.ulzha.spive.app.events.CreateProcess;
import io.ulzha.spive.app.events.CreateStream;
import io.ulzha.spive.app.events.CreateType;
import io.ulzha.spive.app.events.DeleteInstance;
import io.ulzha.spive.app.events.DeleteProcess;
import io.ulzha.spive.app.events.InstanceIopw;
import io.ulzha.spive.app.events.InstanceProgress;
import io.ulzha.spive.app.events.InstanceStatusChange;
import io.ulzha.spive.basicrunner.api.BasicRunnerGateway;
import io.ulzha.spive.basicrunner.api.Umbilical;
import io.ulzha.spive.lib.EventIterator;
import io.ulzha.spive.lib.EventLock;
import io.ulzha.spive.lib.EventLog;
import io.ulzha.spive.lib.EventTime;
import io.ulzha.spive.lib.HandledException;
import io.ulzha.spive.lib.InstanceMain;
import io.ulzha.spive.lib.umbilical.UmbilicalWriter;
import java.time.Instant;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ExecutionException;
import java.util.function.Supplier;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

// basicrunner.*Umbilical seems like an ugly dependency. gateways.BasicRunnerUmbilical? core.util?

/**
 * Glue code generated by Spīve, which facilitates strongly typed input and output.
 *
 * <p>Besides event handling, your Foo application may also comprise lightweight background
 * workloads, unpredictable query serving workloads, long running heavy computation workloads, etc.
 * Implement them as inner classes which implement Runnable, and Spīve platform will pick them up;
 * see Workloads doc. (TODO without reflection? more like an explicit registerWorkloads()?)
 *
 * <p>Note that as soon as one run() method exits, the instance is considered "done", the rest of
 * run() methods get interrupted as well, and the instance is stopped.
 *
 * <p>The workload Runnables may get autoscaled independently from each other. A given Foo instance
 * runs at most one instance of each workload. Apart from this guarantee, your code should not make
 * assumptions as to which (if any) workload Runnables coexist on a given instance of Foo.
 *
 * <p>The workload Runnables can freely rely on in-memory state of Foo, but they should never modify
 * this state, nor create side effects through gateways, except for emitting events through {@code
 * output} gateway.
 */
public interface SpiveInstance {

  default void accept(final CreateEventLog event) {}

  default void accept(final CreateEventLog event, final EventTime eventTime) {
    accept(event);
  }

  default void accept(final CreateInstance event) {}

  default void accept(final CreateInstance event, final EventTime eventTime) {
    accept(event);
  }

  default void accept(final CreateProcess event) {}

  default void accept(final CreateProcess event, final EventTime eventTime) {
    accept(event);
  }

  default void accept(final CreateStream event) {}

  default void accept(final CreateStream event, final EventTime eventTime) {
    accept(event);
  }

  default void accept(final CreateType event) {}

  default void accept(final CreateType event, final EventTime eventTime) {
    accept(event);
  }

  default void accept(final DeleteInstance event) {}

  default void accept(final DeleteInstance event, final EventTime eventTime) {
    accept(event);
  }

  default void accept(final DeleteProcess event) {}

  default void accept(final DeleteProcess event, final EventTime eventTime) {
    accept(event);
  }

  default void accept(final InstanceIopw event) {}

  default void accept(final InstanceIopw event, final EventTime eventTime) {
    accept(event);
  }

  default void accept(final InstanceProgress event) {}

  default void accept(final InstanceProgress event, final EventTime eventTime) {
    accept(event);
  }

  default void accept(final InstanceStatusChange event) {}

  default void accept(final InstanceStatusChange event, final EventTime eventTime) {
    accept(event);
  }

  /**
   * Implements application's interaction boilerplate with a concrete processing runtime and event
   * store. Intended as a layer for enabling powerful mix-and-match options.
   *
   * <p>Despite being generated and replaceable, this layer should be a readable and debuggable part
   * of the stack for application developers. Should strive to eliminate any obscureness of late
   * dependency injection etc.
   */
  class Main extends InstanceMain {
    public static final Logger LOG = LoggerFactory.getLogger(Main.class);

    // useful for running outside framework? Spawn some sort of CLI umbilical?
    //    public static void main(final String... args) {
    //    }

    public static void main(final Umbilical umbilical, final String... args) throws Exception {
      final Supplier<Instant> wallClockTime = Instant::now;

      try (EventLog inputEventLog = EventLog.open(args[0], args[1]);
          EventLog outputEventLog = EventLog.open(args[2], args[3])) {
        final EventIterator eventIterator = new EventIterator(inputEventLog.iterator());

        // FIXME thread-safe supplier
        // FIXME beat outside an event when the write is actually from a concurrent workload
        final UmbilicalWriter umbilicus = umbilical.new Umbilicus(() -> eventIterator.lastTimeRead);

        final EventLock eventLock = new EventLock();
        final SpiveOutputGateway output =
            new SpiveOutputGateway(umbilicus, eventIterator, wallClockTime, eventLock);

        final BasicRunnerGateway runner =
            new BasicRunnerGateway(umbilicus, List.of(args[4].split(",")));

        final Spive app = new Spive(output, runner);

        List<Runnable> workloads = new ArrayList<>();
        workloads.add(new EventLoop<Spive>(umbilicus, eventIterator, app, eventLock));
        workloads.addAll(selectWorkloads(app, args[5]));

        umbilical.addHeartbeat(null); // marks start of all the workloads
        runWorkloads(workloads);
        LOG.info("Instance exiting nominally"); // with L stalling partitions, etc...
      } catch (ExecutionException e) {
        // TODO not leak ExecutionException here.... Cleanup callback may leak here instead?
        LOG.info("Workload failed:", e.getCause());
        umbilical.addError(null, e.getCause());
        throw new HandledException(e.getCause());
      } catch (InterruptedException e) {
        LOG.info("Workload interrupted:", e);
        umbilical.addError(null, e);
        Thread.currentThread().interrupt();
        throw new HandledException(e);
      } catch (Throwable t) {
        // TODO differentiate between errors that propagate from gateways (already appended to the
        // sample) and event handler exceptions, and workload exceptions...?
        LOG.info("Workload failed:", t);
        // Unlike inside event loop, here our best option is to add error at instance level, and not
        // associate it with currentEventTime, because that event may have already been successfully
        // handled, and a success followed by an error would make a confusing sequence of updates.
        // TODO smth quieter for HandledException
        umbilical.addError(null, t);
        throw t;
        // TODO proceed gracefully actually? Other partitions can be processed so long as the
        // crashed one sees no subsequent events? If event log stalls, keep serving read requests
        // for a while? Vice versa as well? Write requests can even be served against the unaffected
        // partitions?
      } finally {
        LOG.info(
            "Instance exiting with K failed partitions, L stalling partitions, and M general workload failures");
      }
    }

    /* make overridable? Or instead, move out of generated spive.gen and subject to optimizer rules */
    private static List<Runnable> selectWorkloads(Spive app, final String workloads) {
      // TODO the rules for workload selection, unsure about them - when to keep a single replica,
      // when to keep redundant replicas? Stuckness is not an easy signal to obtain. Will always
      // task users with providing a health check? Exercise: shard Watchdog but not Frontend?
      // for now just interpret all the inner Runnable classes as workloads
      // TODO with generation this should be done without reflection perhaps?
      //      for (Class<?> cls : app.getClass().getDeclaredClasses()) {
      //        if (!Modifier.isStatic(cls.getModifiers())) {
      //          final Constructor<?> ctor = cls.getDeclaredConstructor(app.getClass());
      //          final Runnable workload = ctor.newInstance(app);
      //        }
      //      }
      if (workloads.equals("event loop only")) {
        return ImmutableList.of();
      } else {
        return ImmutableList.of(app.new Watchdog(), app.new Api());
      }
    }
  }
}
