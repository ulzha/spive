package io.ulzha.spive.example.clicctracc.app.lib;

import io.ulzha.spive.example.clicctracc.app.events.Clicc;
import io.ulzha.spive.lib.Event;
import io.ulzha.spive.lib.EventEnvelope;
import io.ulzha.spive.lib.EventTime;
import io.ulzha.spive.lib.Gateway;
import io.ulzha.spive.lib.LockableEventLog;
import io.ulzha.spive.lib.Type;
import io.ulzha.spive.lib.umbilical.UmbilicalWriter;
import java.io.IOException;
import java.time.Instant;
import java.util.UUID;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.Supplier;

/**
 * Glue code generated by SpÄ«ve, which facilitates strongly typed output.
 *
 * <p>TODO make thread-safe, as this is for use by concurrent workloads
 *
 * <p>The methods are merely adapting app events, via serde for the given Type, to EventLog
 * interface, while implementing the Gateway contract.
 */
public class CliccTraccOutputGateway extends Gateway {
  private final AtomicReference<EventTime> lastEventTime;
  private final AtomicReference<EventTime> lastEventTimeEmitted;
  private final Supplier<Instant> wallClockTime;
  private final LockableEventLog eventLog;

  private static final Type cliccType =
      Type.fromTypeTag("pojo:io.ulzha.spive.example.clicctracc.app.events.Clicc");

  public CliccTraccOutputGateway(
      final UmbilicalWriter umbilicus,
      final AtomicReference<EventTime> lastEventTime,
      final Supplier<Instant> wallClockTime,
      final LockableEventLog eventLog) {
    super(umbilicus);
    this.lastEventTime = lastEventTime;
    this.lastEventTimeEmitted = new AtomicReference<>(EventTime.INFINITE_PAST);
    this.wallClockTime = wallClockTime;
    this.eventLog = eventLog;
  }

  /**
   * Blocks until either successfully appended, or a competing prior append has been positively
   * detected.
   *
   * @return true if appended, false if not because the latest stored Event has time >
   *     lastEventTime.
   * @throws IllegalArgumentException if event.time <= lastEventTime.
   */
  private boolean emit(Event event, EventTime lastEventTime) {
    // TODO check that it belongs to the intended stream and the intended subset of partitions
    long sleepMs = 10;
    long sleepMsMax = 100000;
    EventEnvelope ee = EventEnvelope.wrap(event);
    while (true) {
      try {
        return eventLog.appendIfPrevTimeMatch(ee, lastEventTime);
        // TODO report that we're leading
      } catch (IOException e) {
        // likely an intermittent failure, let's keep trying
        umbilicus.addWarning(e);
      }
      // unlisted exceptions are likely permanent failures, let them crash the instance
      try {
        sleepMs = Math.min(sleepMs * 10, sleepMsMax);
        Thread.sleep(sleepMs);
      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        throw new RuntimeException(e);
      }
    }
  }

  /**
   * Emits between event handlers, first checking if the check returns true for in-memory state at
   * that point in time.
   *
   * <p>Blocks until either successfully appended, which may be indefinitely preempted by competing
   * appends, or until the check returns false.
   *
   * <p>TODO possible to provide fairer guarantees than indefinitely?
   *
   * <p>TODO a version with deadline? For predictable response time in server scenarios
   *
   * <p>TODO emitWhen version that evaluates check on every transition? Or is that higher level API
   */
  public boolean emitIf(Supplier<Boolean> check, Clicc payload) {
    return emitIf(check, cliccType, payload);
  }

  private <T> boolean emitIf(Supplier<Boolean> check, Type type, T payload) {
    try {
      while (true) {
        final EventTime eventTime = awaitAdvancing();

        try {
          eventLog.lock();
          if (lastEventTime.get() == null || lastEventTime.get().compareTo(eventTime) < 0) {
            if (check.get()) {
              final Event event = new Event(eventTime, UUID.randomUUID(), type, payload);
              if (emit(event, lastEventTime.get())) {
                lastEventTimeEmitted.set(eventTime);
                return true;
              }
            } else {
              return false;
            }
          }
        } finally {
          eventLog.unlock();
        }
      }
    } catch (Throwable t) {
      umbilicus.addError(t);
      throw t;
    }
  }

  /**
   * Emits between event handlers, first checking if the check returns true for in-memory state at
   * eventTime.
   *
   * <p>Blocks until either successfully appended (which may be preempted by a burst of competing
   * appends, even if at call time all events in the log have time < eventTime), or until a winning
   * prior append has been positively detected (the latest event read from the log has time >=
   * eventTime), or until the check returns false.
   *
   * <p>TODO possible to provide fairer guarantees than haphazard competition?
   */
  public boolean emitIf(Supplier<Boolean> check, Clicc payload, EventTime eventTime) {
    return emitIf(check, cliccType, payload, eventTime);
  }

  private <T> boolean emitIf(Supplier<Boolean> check, Type type, T payload, EventTime eventTime) {
    final Event event = new Event(eventTime, UUID.randomUUID(), type, payload);
    try {
      awaitAdvancing();

      try {
        eventLog.lock();
        if (lastEventTime.get() == null || lastEventTime.get().compareTo(eventTime) < 0) {
          if (check.get()) {
            if (emit(event, lastEventTime.get())) {
              lastEventTimeEmitted.set(eventTime);
              return true;
            }
          }
        }
        return false;
      } finally {
        eventLog.unlock();
      }
    } catch (Throwable t) {
      umbilicus.addError(t);
      throw t;
    }
  }

  /**
   * Picks the earliest event time that may be used for the next event so that an append operation
   * has chances of succeeding, according to information available in local instance.
   *
   * <p>This method blocks at least until event handling operations (locking reads) from the
   * underlying log have caught up with the last event emitted, as observed by current thread.
   *
   * <p>Note that the returned event time may nevertheless fall earlier than the latest event time
   * actually present in the underlying log, in case of a concurrent append from a sporadic workload
   * thread or a remote instance.
   *
   * @return an EventTime that closely corresponds to wall clock time and is not simultaneous with
   *     (has an instant strictly larger than the instant of) the last event time read from the
   *     underlying log.
   */
  private EventTime awaitAdvancing() {
    long waitMillis = 1;
    long waitMillisMax = 1000;

    // in testing, this Supplier call also advances lastEventTime. Should create a cleaner harness
    Instant tentativeInstant = wallClockTime.get();

    // FIXME null until the first event is read, right?
    while (lastEventTime.get().compareTo(lastEventTimeEmitted.get()) < 0
        || tentativeInstant.compareTo(lastEventTime.get().instant) <= 0) {
      try {
        Thread.sleep(waitMillis);
      } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        throw new RuntimeException(e);
      }
      waitMillis = Math.min(waitMillis * 2, waitMillisMax);
      tentativeInstant = wallClockTime.get();
    }
    return new EventTime(tentativeInstant);
  }

  public void emitConsequential(Clicc payload) {
    emitConsequential(cliccType, payload);
  }

  private <T> void emitConsequential(Type type, T payload) {
    try {
      final EventTime prevTime = lastEventTime.get();
      final EventTime eventTime = new EventTime(prevTime.instant, prevTime.tiebreaker + 1);
      try {
        eventLog.lockConsequential();
        // If emitConsequential gets erroneously invoked from another thread than EventLoop, then
        // this deadlocks immediately, which points out the problem well... Perhaps should add a
        // descriptive exception though.
        final Event event = new Event(eventTime, UUID.randomUUID(), type, payload);
        if (emit(event, prevTime)) {
          System.out.println("Emitted consequential event, wdyt? " + eventTime);
          lastEventTimeEmitted.set(eventTime);
        } else {
          // TODO only throw if something worse than a competing identical append happened...
          throw new RuntimeException("not well thought out");
        }
      } finally {
        eventLog.unlock();
      }
    } catch (Throwable t) {
      umbilicus.addError(t);
      throw t;
    }
  }
}
